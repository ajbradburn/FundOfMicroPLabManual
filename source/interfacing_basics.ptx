<?xml version='1.0' encoding='utf-8'?>
<!-- Chapters are enclosed with <chapter> tags. Use xml:id to -->
<!-- uniquely identify the chapter.  The @xmlns:xi atrowibute  -->
<!-- is needed if you use xi:include in this file             -->
<chapter xml:id="ch-first" xmlns:xi="http://www.w3.org/2001/XInclude">

  <!-- Title -->
  <xi:include href="./titles/interfacing_basics.ptx" />

  <!-- Introduction -->
  <xi:include href="./introductions/interfacing_basics.ptx" />

  <!-- 
    Material:
      https://open.umn.edu/opentextbooks/textbooks/think-python-how-to-think-like-a-computer-scientist
      Chapter 7: Itteration
      Chapter 8: Strings
  -->

  <section>
    <title>
      Associated Reading
    </title>
    <ul>
      <li>
        <url href="https://open.umn.edu/opentextbooks/textbooks/think-python-how-to-think-like-a-computer-scientist">Think Python: How to Think Like a Computer Scientist. 2nd Edition</url>
      </li>
      <ul>
        <li>
          Chapter 7: Itteration
        </li>
        <li>
          Chapter 8: Strings
        </li>
      </ul>
    </ul>
  </section>
  <section>
    <p>
      Before we can start programming, and seeing the fruits of our labor on something other than a computer screen, it is necessary to attach our Raspberry Pi to peripherals. As you know, when working with electronics, you have to be aware of the power limitations of the components you're working with. You have to design your circuits with this in mind.
    </p>
    <p>
      While the circuitry of this lab isn't complicated, doing something incorrectly can result in damage to your Raspberry Pi. It is recommended that you check, and double check your work before powering up your Raspberry Pi.
    </p>
    <p>
      If you do any of your own design, make sure that you read up on the voltage, and current limits for each of the Raspberry Pi GPIO pins. Allowing too much current or voltage can easily cause damage.
    </p>
      <subsection>
        <title>
          Required Equipment
        </title>
        <p>
          These are the required components.
        </p>
        <table>
          <tabular>
          <row>
            <cell>Amount</cell>
            <cell>Part Type</cell>
          </row>
          <row>
            <cell>1</cell>
            <cell>Breadboard</cell>
          </row>
          <row>
              <cell>1</cell>
              <cell>Film/Foil Capacitor</cell>
          </row>
          <row>
              <cell>6</cell>
              <cell>Red LED</cell>
          </row>
          <row>
              <cell>6</cell>
              <cell>470Ω Resistor</cell>
          </row>
          <row>
              <cell>1</cell>
              <cell>10KΩ Resistor</cell>
          </row>
          <row>
              <cell>1</cell>
              <cell>Raspberry Pi 3</cell>
          </row>
          <row>
              <cell>1</cell>
              <cell>Push button</cell>
          </row>
          <row>
            <cell>Handful</cell>
            <cell>Male to Female Jumper Wires</cell>
          </row>
          <row>
            <cell>Handful</cell>
            <cell>Solid Core Jumper Wires</cell>
          </row>
        </tabular>
      </table>
    </subsection>
    <subsection>
      <title>
        The Design
      </title>
      <p>
        Our objective is to create a dice rolling circuit. We will provide user input through a momentary switch, and we will get output through LEDs. Our little computer will run a program that responds to a button push, generates a random number between 1 and 6, and then displays the value generated by illuminating a corresponding number of LEDs.
      </p>
      <p>
        I recommend that care be taken with the placement of the components, as the following lab will build upon this initial setup. Setting it up correctly the first time will save you the trouble of rebuilding things.
      </p>
      <p>
        This is what we are aiming for:
      </p>
      <figure>
        <caption>The Completed Circuit</caption>
        <image source="photographs/interfacing_basics_bb.jpg">
          <description>A Raspberry Pi 3 with GPIO pins connected to an array of LEDs and a momentary switch.</description>
        </image>
      </figure>
      <figure>
        <caption>The Completed Circuit</caption>
        <image source="generated/interfacing_basics_bb">
          <description>A Raspberry Pi 3 with GPIO pins connected to an array of LEDs and a momentary switch.</description>
        </image>
      </figure>
      <figure>
        <caption>Circuit Schematic for Momentary Switch</caption>
        <image source="generated/interfacing_basics_img01">
          <description>A Raspberry Pi 3 with GPIO pins connected to an array of LEDs and a momentary switch.</description>
        </image>
      </figure>
      <figure>
        <caption>Circuit Schematic for LEDs</caption>
        <image source="generated/interfacing_basics_img02">
          <description>A Raspberry Pi 3 with GPIO pins connected to an array of LEDs and a momentary switch.</description>
        </image>
      </figure>
    </subsection>
    <subsection>
      <title>Raspberry Pi GPIO Connections</title>
      <p>
        In order to match the code that will follow, special care will be needed with matching the correct GPIO to the proper components.
      </p>
      <figure>
        <caption>Raspberry Pi 3 GPIO Pinout</caption>
        <image source="images/gpiopinsv3withpi">
          <description>The GPIO pinout for the Raspberry Pi 3.</description>
        </image>
      </figure>
      <table>
        <tabular>
          <row>
            <cell>GPIO Designation</cell>
            <cell>Header Pin</cell>
            <cell>Component</cell>
          </row>
          <row>
            <cell>GND</cell>
            <cell>Pin 9</cell>
            <cell>GND (Shared)</cell>
          </row>
          <row>
            <cell>GPIO25</cell>
            <cell>Pin 22</cell>
            <cell>Switch</cell>
          </row>
          <row>
            <cell>GPIO13</cell>
            <cell>Pin 33</cell>
            <cell>LED 1</cell>
          </row>
          <row>
            <cell>GPIO16</cell>
            <cell>Pin 36</cell>
            <cell>LED 2</cell>
          </row>
          <row>
            <cell>GPIO19</cell>
            <cell>Pin 35</cell>
            <cell>LED 3</cell>
          </row>
          <row>
            <cell>GPIO20</cell>
            <cell>Pin 38</cell>
            <cell>LED 4</cell>
          </row>
          <row>
            <cell>GPIO26</cell>
            <cell>Pin 37</cell>
            <cell>LED 5</cell>
          </row>
          <row>
            <cell>GPIO21</cell>
            <cell>Pin 40</cell>
            <cell>LED 6</cell>
          </row>
        </tabular>
      </table>
    </subsection>
    <subsection>
      <p>
        Using the schematics, and details provided, wire up the components to the Raspberry Pi. When done, boot it up, and proceed to the next section.
      </p>
    </subsection>
  </section>
  <section>
    <p>
      With everything wired up, transcribe the following program, and run it.
    </p>
    <listing>
      <program>
        <input>
          1|  import signal
          2|  import sys
          3|  import RPi.GPIO as GPIO
          4|  from time import sleep
          5|  import random
          6|
          7|  # Define a class to handle displaying a number on the LED array.
          8|  class led_display:
          9|    # Define LED pins. There are a number of ways to do this
         10|    # I am doing it this way because I want it to be readable, and meaningful.
         11|    lp1 = 13 # pin for LED 1
         12|    lp2 = 16
         13|    lp3 = 19
         14|    lp4 = 20
         15|    lp5 = 26
         16|    lp6 = 21
         17|    lp = [lp1, lp2, lp3, lp4, lp5, lp6] # An array of all LED pins in LED order.
         18|
         19|    # Class constructor function.
         20|    # Initialize essential settings.
         21|    def __init__(self):
         22|      GPIO.setmode(GPIO.BCM)
         23|      for l in self.lp:
         24|        GPIO.setup(l, GPIO.OUT)
         25|
         26|    # Class Destructor function.
         27|    # Do things that should be done with stopping.
         28|    def __del__(self):
         29|      GPIO.cleanup()
         30|      return
         31|
         32|    # Display function: Illuminate n LEDs based upon a number provided.
         33|    def display(self, number):
         34|      if number &lt; 0:
         35|        return False
         36|
         37|      for i in range(0, len(self.lp)):
         38|        n = i + 1
         39|        if n &lt;= number:
         40|          GPIO.output(self.lp[i], 1)
         41|        else:
         42|          GPIO.output(self.lp[i], 0)
         43|
        </input>
      </program>
    </listing>
    <listing>
      <program>
        <input>
          44|    # An animation to indicate something is happening.
          45|    def interlude(self):
          46|      # Clear all of the LEDs quickly.
          47|      for l in self.lp:
          48|        GPIO.output(l, 0)
          49|      sleep(0.100)
          50|      # Turn on each LED with a small pause between each.
          51|      for l in self.lp:
          52|        GPIO.output(l, 1)
          53|        sleep(0.020)
          54|      # Turn off each LED with a small pause between each.
          55|      for l in self.lp:
          56|        GPIO.output(l, 0)
          57|        sleep(0.020)
          58|
          59|  button_pin = 25
          60|
          61|  # Upon Ctrl-C, exit the application.
          62|  def signal_handler(sig, frame):
          63|    global led_display
          64|    del led_display
          65|    sys.exit(0)
          66|
          67|  def roll_dice(channel):
          68|    led_display.interlude()
          69|    roll = random.randint(1, 6)
          70|    led_display.display(roll)
          71|    print("New roll of: {}.".format(roll))
          72|
          73|  # Start monitoring for, and responding to, a button press.
          74|  def start(button_pin, led_display):
          75|    GPIO.setup(button_pin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
          76|    # Monitor the button pin, and when it is pressed for 100ms, call the function roll_dice.
          77|    GPIO.add_event_detect(button_pin, GPIO.FALLING, callback=roll_dice, bouncetime=100)
          78|    signal.signal(signal.SIGINT, signal_handler)
          79|    signal.pause()
          80|
          81|  led_display = led_display()
          82|  start(button_pin, led_display)
        </input>
      </program>
    </listing>
    <p>
      This program, unlike the rest we've done so far, will not end until you stop it manually. While it is running, you can press the button on the bread board, and then view the numerical output.
    </p>
  </section>
  <section>
    <subsection>
      <p>
        The <c>RPi.GPIO</c> library offers two different ways to refer to the pins that you want to use. The <c>GPIO.BCM</c> mode that is used in our example program on line 22 sets up the program to use the pins as they are known by the Broadcom chip on the Raspberry Pi. The other option, <c>GPIO.BOARD</c> allows you to refer to the pins by their header number. In a later experiment, we will make use of some more advanced features that require the <c>GPIO.BCM</c> mode. For that reason, we are using it here.
      </p>
    </subsection>
    <subsection>
      <p>
        Next, on line 17, you'll observe that we created a list that contains all 6 pin numbers attached to our LEDs. On line 23, we use a for loop to iterate over that list, and call <c>GPIO.setup([pin number], GPIO.OUT)</c>. This function configures the pin to operate in output mode. When your intent is to control something with the pin, output mode is what you want. However, if you're looking to read a value, or detect a button press, input mode is needed.
      </p>
      <p>
        On line 75, we use the <c>GPIO.setup()</c> function again, but for the button. In this case we use the input mode, and add a parameter that also configures a pull-up resistor. If you're not familiar with it, a pull-up resistor is a high value resistor connected to a voltage source and causes the signal line to rest at the high value instead of floating when not used. The alternative is a pull-down resistor which is just a high value resistor connected to GND and causes the line to stay at a low value when not used.
      </p>
    </subsection>
    <subsection>
      <p>
        There are a number of possible approaches to determining when the button is pressed, but the most reliable way will generally always be one that relies upon hardware interrupts. On line 77, we make use of the <c>GPIO.add_event_detect()</c> function to monitor the button pin for a transition from high to low. What that happens, the function <c>roll_dice</c> will be called.
      </p>
      <p>
        Upon being called, the <c>roll_dice</c> function will roll a random number, and display the number on the LED display we've created.
      </p>
      <!-- Add an appendix for? -->
      <!-- Analog Read, Digital Read -->
      <!-- Analog Write, Digital Write -->
      <!-- Debouncing -->
    </subsection>
  </section>
  <!-- 
    GPIO libraries and modes.
    IN vs OUT
    Read vs Detect
    Analogue Read vs Digital Read
    PWM out, vs Digital Out
    Classes, definition and usage.
        Putting the class definition in a seperate file, you'd have a much smaller program?
        Construction, Destruction
    Variable Scope. global keyword.
  -->
  <section>
    <title>
      Troubleshooting
    </title>
    <subsection>
      <title>
        Switch
      </title>
      <p>
        Double check the orientation of the switch. Pins 1 and 2 are connected to each other. Pins 3 and 4 are connected to each other. If the switch is oriented 90° in the wrong direction, you'll be short circuiting the switch, and pressing it will no produce any results.
      </p>
    </subsection>
    <subsection>
      <title>
        LEDs
      </title>
      <p>
        Double check the orientation of the LED. Because of their diode characteristics, having them reversed will prevent current from flowing through them, at the voltages we are using.
      </p>
    </subsection>

  </section>
</chapter>
